
set class GsComMethNode
category: '*maglev-Instance creation'
classmethod:
checkRubyInfoMasks
 "check classVars defined by bom.c against constants hardcoded in
  this class."
 (IsPrivate_mask bitOr: IsProtected_mask) == 16r600 ifFalse:[ self halt ].
 ^ true
%


set class GsComMethNode
category: '*maglev-Documentation'
classmethod:
comment
^
'A GsComMethNode represents a single method in the Smalltalk sense.
 It can be an anonymous method, as for a  doit .  For each GsComMethNode,
 A GsComMethNode is the root node of the IR graph for each invocation of 
 the code generator .
 The generator emits one or more instances of GsNMethod, one for the
 home method of this node, and one for any non-inlined blocks within the method.
 The instVars are

    selector, a Symbol , or nil for an anonymous method.
    theClass, a Behavior, class in which method is to be an instanceMethod,
                may be nil for an anonymous method.  Note generator does not
                install method in method dictionary.
    arguments, an Array , each element is a GsComVarLeaf
    temps    , an Array , each element is a GsComVarLeaf
    body     , an Array , each element is a GsCompilerIRNode for a statement 
    methInfo , a SmallInteger , 0 for a ruby method .
        bit masks of the fields are  
            requiresVc 0xFF (not used by smalltalk, 0=no, 1=yes, 
              2=force all temps to be allocated in Vc, and copy all args to VC)
            protectedType 0xFF00 (Smalltalk base image code security)    
            primNumber 0xFFFF0000 (short, a Smalltalk primitive number)
    rubyInfo , a SmallInteger 
        bit masks of the fields are  (per comparse.ht)
		envId        16rFF default env for sends in this method
		isRuby      16r100 (1 in Ruby, 0 in smalltalk)
		isPrivate   16r200            
		isProtected 16r400
		isEval      16r800  
          lineNumBias 16rFFFFFF000
          isBridge   16r1000000000
                   16rFF0000000000  defaultReturnArgNumber (1-based)
        If isBridge bit is true, then a bridge method is generated,
        and except for sends of variants of #call within bridge methods for
        ExecBlock, all message sends other than to super will use SEND_CURRENT
        bytecode.
        If defaultReturnArgNumber is non zero, then default return value
        is that argument instead of value of the last statement.
    rubyOptArgsBits, a SmallInteger with bits  describing which args
        in a ruby method have explicitly coded default value initializers,
        maximum of 61 args to such a method.
    nonBridgeSelector,   a Symbol or nil, 

    source, a String, the source code for the method, to be saved in the
          debug information for the generated method.

    fileName, a String, name of a Ruby source file , or nil.

    endSrcOffset,  1-based, if non-nil defines the end srcOffset within a Ruby 
       source file for this method, and beginning source offset
       defined by this nodes" srcOffset maybe > 1 , and sourceString
       is expected to be for an entire file.

    lineNumber is one-based .
      For Smalltalk IR trees generated by comparse.c , lineNumber is
      for use in debugging the compiler, and debug info is generated from
      the srcOffset only.
      For Ruby IR trees ,
      lineNumber in a GsComMethNode is used to generate a comment
      in the source string for the method about where in the source file
      it came from.  The sourceString in the GsComMethNode may be a source
      string for an entire file, and the generator will carve out of that source
      string the bytes from MethNode.srcOffset to methNode.endSrcOffset ,
      and append a comment with  methNode.lineNumber and methNode.fileName
      to the end of the carved out string.
'
%


set class GsComMethNode
category: '*maglev-Accessing'
classmethod:
maxRubyFixedArgs
  ^ GEN_MAX_RubyFixedArgs
%


set class GsComMethNode
category: '*maglev-Instance creation'
classmethod:
new

"disallowed , use newRuby or newSmalltalk"
self shouldNotImplement: #new
%


set class GsComMethNode
category: '*maglev-Instance creation'
classmethod:
newRuby
  ^ self _basicNew initialize setRuby
%


set class GsComMethNode
category: '*maglev-Instance creation'
classmethod:
newSmalltalk
  ^ self _basicNew initialize setSmalltalk
%


set class GsComMethNode
category: '*maglev-Instance creation'
method:
addMethodProtection: anInt
  "used in building IR to transfer default private/protected from
   current class to this method node, if method not automatically
   private (like  initialize method)"
  | prot mask newBits iv |
  mask := 16r600 .
  iv := rubyInfo . 
  prot := (iv bitAnd: mask) bitShift: -9 . "inline methodProtection"
  anInt > prot ifTrue:[
    (anInt >= 0 and:[anInt <= 2]) ifFalse:[
       ArgumentError signal:'invalid method protection argument'
    ].
    newBits := anInt bitShift: 9 .
    rubyInfo := (iv bitAnd: (mask bitInvert))  bitOr: newBits
  ].
%


set class GsComMethNode
category: '*maglev-Instance creation'
method:
appendArg: aGsComVarLeaf
  aGsComVarLeaf varKind == COMPAR_METHOD_ARG_VAR ifFalse:[
    self error: 'bad arg kind ', aGsComVarLeaf varKindString 
  ].
  arguments addLast: aGsComVarLeaf
%


set class GsComMethNode
category: '*maglev-Instance creation'
method:
appendStatement: aNode
  aNode sourceOffset ifNil:[ | bsiz |
    (bsiz := body size) > 0 ifTrue:[
      aNode sourceOffset:( (body at: bsiz) sourceOffset).
    ]
  ].
  body addLast: aNode .
  srcOffset ifNil:[ | ofs |
    ofs := aNode sourceOffset .
    ofs ifNotNil:[ srcOffset := ofs ] 
        ifNil:[ lineNumber ifNil:[ lineNumber := aNode lineNumber]]. 
  ].
%


set class GsComMethNode
category: '*maglev-Instance creation'
method:
appendTemp: aGsComVarLeaf
  | knd |
  knd := aGsComVarLeaf varKind .
  (knd == COMPAR_METHOD_TEMP_VAR or:[ knd == COMPAR_METH_VC_GLOBAL]) ifFalse:[
    self error: 'bad arg kind ', aGsComVarLeaf varKindString 
  ].
  temps addLast: aGsComVarLeaf
%


set class GsComMethNode
category: '*maglev-Accessing'
method:
arguments
  ^ arguments
%


set class GsComMethNode
category: '*maglev-Instance creation'
method:
class: aBehavior
  theClass := aBehavior
%


set class GsComMethNode
category: '*maglev-Instance creation'
method:
endSourceOffset: anOffset
  endSrcOffset := anOffset
%


set class GsComMethNode
category: '*maglev-Instance creation'
method:
envId
  ^ rubyInfo bitAnd: Env_mask
%


set class GsComMethNode
category: '*maglev-Instance creation'
method:
environment: anInteger
  (anInteger < 0 or:[ anInteger > 255]) ifTrue:[ 
     anInteger error:'out of range'
  ].
  rubyInfo := (rubyInfo bitAnd:( Env_mask bitInvert)) bitOr: anInteger 
%


set class GsComMethNode
category: '*maglev-Accessing'
method:
fileName
  ^ fileName
%


set class GsComMethNode
category: '*maglev-Instance creation'
method:
fileName: aString
  fileName := aString 
%


set class GsComMethNode
category: '*maglev-Instance creation'
method:
fileName: nameString source: srcString
  fileName := nameString .
  source := srcString
%


set class GsComMethNode
category: '*maglev-Printing'
method:
fileNameForPrint
  | sz res |
  fileName == nil ifTrue:[ ^ 'nil' ].
  (res := String new) add: $' .
  (sz := fileName size) > 25 ifTrue:[
    res addAll:( fileName copyFrom: sz - 25 to: sz ) 
  ] ifFalse:[
    res addAll: fileName .
  ] .
  res add: $' .
  ^ res
%


set class GsComMethNode
category: '*maglev-Instance creation'
method:
forceAllArgsTmpsToVc
  "set requiresVc bits to 2 "
  methInfo := methInfo bitOr: 16r2
%


set class GsComMethNode
category: '*maglev-Instance creation'
method:
initialize
  kind := COMPAR_METHOD_NODE .
  arguments :=  { } .
  temps :=  { } .
  body := { } .
  "nonBridgeSelector left as nil"
  rubyInfo := 0 .
  rubyOptArgsBits := 0 .
%


set class GsComMethNode
category: '*maglev-Instance creation'
method:
insertFirstStatement: aNode
  body insertAll: { aNode } at: 1 .
%


set class GsComMethNode
category: '*maglev-Instance creation'
method:
lastAsRubyReturn 
  | last bdy bdySize rtn sofs defRtn |
  bdy := body .
  bdySize := bdy size.
  last := bdy atOrNil: bdySize .
  (defRtn := rubyInfo bitAnd: DefaultReturnArgNum_mask) ~~ 0 ifTrue:[
    last class == GsComReturnNode ifFalse:[ | argNum |
      argNum := defRtn bitShift: 0 - DefaultReturnArgNum_shift .
      rtn := GsComReturnNode new return: 
	     (GsComVariableNode _basicNew leaf: (arguments at: argNum)) .
      sofs := last ifNotNil:[ last sourceOffset ] ifNil:[ self sourceOffset].
      sofs ifNotNil:[ rtn sourceOffset: sofs ].
      self appendStatement: rtn
    ]
  ] ifFalse:[
    last ifNil:[
      last := GsComLiteralNode newNil returnNode .
      bdy at: 1 put: last .
    ] ifNotNil:[ 
      rtn := last returnNode .
      (sofs := last sourceOffset) ifNotNil:[ rtn sourceOffset: sofs ].
      bdy at: bdySize put: rtn 
    ].
  ].
%


set class GsComMethNode
category: '*maglev-Instance creation'
method:
methodProtection
  "return the ruby method protection bits, 
   result  0==public,  1==protected, 2==private  "

  ^ (rubyInfo bitAnd: 16r600) bitShift: -9
%


set class GsComMethNode
category: '*maglev-Instance creation'
method:
nonBridgeSelector: aSymbol
  nonBridgeSelector := aSymbol
%


set class GsComMethNode
category: '*maglev-Instance creation'
method:
optArgsBits: aSmallInt
  aSmallInt _isSmallInteger ifFalse:[ aSmallInt error:'invalid arg'].
  rubyOptArgsBits := aSmallInt
%


set class GsComMethNode
category: '*maglev-Printing'
method:
printFormattedOn: aStream
  super printOn: aStream .
  aStream nextPutAll: ' file:' ; nextPutAll: self fileNameForPrint ;
    print:'selector: ' symbol: selector ;
    nextPutAll:' theClass: '; 
      nextPutAll: (theClass ~~ nil ifTrue:[ theClass name] ifFalse:['nil '])  ; 
    nextPutAll:' methInfo:'; nextPutAll: '16r'; nextPutAll: methInfo asHexString ; cr ;
    nextPutAll:' rubyInfo:'; nextPutAll: '16r'; nextPutAll: rubyInfo asHexString ; cr ;
    nextPutAll:'args:' ; do: arguments ; 
    nextPutAll:'temps:' ; do: temps ;
    nextPutAll:'body:' ; do: body ;
    nextPut: $) ; cr .
%


set class GsComMethNode
category: '*maglev-Instance creation'
method:
rubyDefaultReturnArg: argNum
  rubyInfo := rubyInfo bitOr: 
    ((argNum bitShift: DefaultReturnArgNum_shift) bitAnd: DefaultReturnArgNum_mask)
%


set class GsComMethNode
category: '*maglev-Accessing'
method:
selector
  ^ selector
%


set class GsComMethNode
category: '*maglev-Instance creation'
method:
selector: aSymbol
  "different implementation(s) in .mcz"
  (GsComSelectorLeaf reimplementationAllowed: aSymbol inEnv: self envId) ifFalse:[
      RubyScriptError signal: 'reimplementation of special selector ' , aSymbol,
                ' not allowed , near line ' , lineNumber asString , ' of ' , fileName asString .
  ].
  selector := aSymbol 
%


set class GsComMethNode
category: '*maglev-runtime'
method:
selector_forBridge: aSymbol env: envId
  (GsComSelectorLeaf reimplementationAllowed: aSymbol inEnv: envId) ifFalse:[
     GsFile gciLogServer:'WARNING, reimplementation of  ', aSymbol , ' as bridge method may have no effect' .
  ].
  selector := aSymbol 

%


set class GsComMethNode
category: '*maglev-Instance creation'
method:
setRuby
  methInfo := 16rFFFF0000 . "primNumber:=-1, protected:=0,reqVc:=0"
  rubyInfo := rubyInfo bitOr: Ruby_mask . "isRuby:= 1 "
%


set class GsComMethNode
category: '*maglev-Instance creation'
method:
setRubyBridge
  rubyInfo := rubyInfo bitOr: IsBridge_mask  
%


set class GsComMethNode
category: '*maglev-Instance creation'
method:
setRubyEval
  rubyInfo := rubyInfo bitOr: IsRubyEval_mask
%


set class GsComMethNode
category: '*maglev-Instance creation'
method:
setRubyLineNumberBias: anInt
   " field in rubyInfo with mask,   lineNumBias 16rFFFFFF000 "
   " intended to be called only once for each instance of GsComMethNode"
  anInt ~~ 0 ifTrue:[
    rubyInfo := rubyInfo bitOr: ((anInt bitAnd: 16rFFFFFF) bitShift: 12)
  ]
%


set class GsComMethNode
category: '*maglev-Instance creation'
method:
setRubyPrivate
  rubyInfo := rubyInfo bitOr: IsPrivate_mask  
%


set class GsComMethNode
category: '*maglev-Instance creation'
method:
setRubyProtected
  rubyInfo := rubyInfo bitOr: IsProtected_mask  
%


set class GsComMethNode
category: '*maglev-Instance creation'
method:
setSmalltalk
  methInfo := 16rFFFF0000 . "primNumber:=-1, protected:=0,reqVc:=0"
  rubyInfo := 0 .
%


set class GsComMethNode
category: '*maglev-Instance creation'
method:
source: aString
  source := aString
%


set class GsComMethNode
category: '*maglev-Printing'
method:
summary
  | str |
  str := String new .
  str addAll:  ' file:' ; addAll: self fileNameForPrint ;
    addAll: ' line ' ; addAll: lineNumber asString ;
    addAll: ' selector: ' ; addAll: selector  .
  ^ str
%

